<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_starting_position</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>par_character</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Main variables.

 // Flag, checking if everything has been initialized. Prevents possible errors:
 // _____________________________________________________________________________________________________________________________ 
 
    is_initialized = false;
 
 // ID:
 // _____________________________________________________________________________________________________________________________ 
  
    character_id = global.character_index; // &gt; The character we're playing as.

 // State:
 // _____________________________________________________________________________________________________________________________ 
 
    state          = 1; // &gt; The characters current state.
    previous_state = 0; // &gt; Characters previous state.
    state_timer    = 0; // &gt; Keeps track how long the character is in a state. Only used for certain states.
    physic_state   = 0; // &gt; Characters physic state. (0 &gt; Default, 1 &gt; Underwater)
        
 // Flags:
 // _____________________________________________________________________________________________________________________________ 
 
    f_launch_angle     = 90; // &gt; The angle used after leaving a ramp/slope. Defined by the tiles creation event. Defaults at 90.   
    f_launch_allow     = 1;  // &gt; Checks if the character can launch on a tile.
    f_launch_direction = 1;  // &gt; Prevents the character from launching when not moving towards the tiles launch direction.
    f_angle_change     = 0;  // &gt; Flag used to rotate the character at certain angles on tiles. Defined by the tiles creation event. Default 1.
    f_edge_skip        = 0;  // &gt; Skips edge collision checking to prevent getting stuck on certain tiles after landing on them (such as quarter ellipes). Defined by the tiles creation event. Default 0.
    f_ceiling_movement = 0;  // &gt; When set to 1, the character is allowed to adapt and move on the ceiling. Set to 0 to prevent that.
    f_edge_exception   = 0;  // &gt; Prevent the character from grabbing a angle of 90/270 on edges.
    
 // Movement variables.
 // Horizontal / X:
 // _____________________________________________________________________________________________________________________________
 
    x_allow         = true;     // &gt; Whether or not the character can move horizontally.
    x_speed         = 0;        // &gt; The (current) horizontal speed.
    x_speed_top     = 6;        // &gt; How fast the character can move while on flat ground.
    x_speed_max     = 16;       // &gt; Fastest the character can move horizontally.
    x_speed_limit   = false;    // &gt; Whether or not to limit the characters horizontal speed. You probably wanna keep this off.
    x_acceleration  = 0.046875; // &gt; The horizontal acceleration while grounded.
    x_deceleration  = 0.5;      // &gt; The horizontal deceleration while groundedn.
    x_slope_factor  = 0.125;    // &gt; Rate at which the character slows down on slopes.
    x_air_accel     = 0.09375;  // &gt; The horizontal acceleration while in air.
    x_temp_accel    = 0;        // &gt; Stores the acceleration value temporarily.
    x_temp_decel    = 0;        // &gt; Stores the deceleration value temporarily.
    x_temp_friction = 0;        // &gt; Stores the friction value temporarily.
    g_speed         = 0;        // &gt; Stores the ground speed.
    
 // Vertical / Y:
 // _____________________________________________________________________________________________________________________________ 
 
    y_allow               = true;    // &gt; Whether or not the character can move vertically.
    y_speed               = 0;       // &gt; The (current) vertical speed.
    y_speed_max           = 16;      // &gt; Fastest the character can move vertically.
    y_speed_limit         = false;   // &gt; Whether or not to limit the characters vertical speed. You probably wanna keep this off.
    y_acceleration        = 0.21875; // &gt; The force of gravity applied to the character.
    y_common_acceleration = 0.21875; // &gt; Stores the original acceleration value for quick access.
    y_conversion          = 1;       // &gt; Speed conversion when landing on slopes.
    
 // Speed samples:
 // &gt; Used to prevent the character from loosing collision when he goes beyond his max speed. Pixel limit to divide horizontal and vertical movement.
 // _____________________________________________________________________________________________________________________________ 
 
    x_sample = 13; 
    y_sample = 13; 
    
 // Terrain / Collision variables:
 // _____________________________________________________________________________________________________________________________ 
 
    ground           = false; // &gt; Checks if the character is grounded.
    collision_layer  = 0;     // &gt; The current terrain layer. Used for various things like loops.
    floor_mode       = 0;     // &gt; The current floor mode (0 to 4). Used for various things like launching off slopes.
    platform_mode   = true;
    platform_id      = noone; // &gt; The id of the platform we're grounded on.
    platform_check   = 0;     // &gt; Checks if teh characters is grounded on a platform.
    platform_timer   = 30;    // &gt; Used to reset the platform check. Preventing that the character can get stuck or bump off platforms.
    swing_id         = noone; // &gt; The id of the swing platform we're grounded on.
    disable_wallstop = false; // &gt; If true, we disable the horizontal speed stop after hitting a wall. This is required for launching on slopes.
    
 // Angle variables:
 // _____________________________________________________________________________________________________________________________ 
 
    angle          = 0; // &gt; The (current) angle of the character while grounded. Not related to the animation angle.
    angle_round    = 0; // &gt; The (current) rounded angle of the character while grounded.
    angle_relative = 0; // &gt; The (current) relative to gravity angle of the character.
    angle_hold     = 0; // &gt; Used to smoothen angle values.
    angle_previous = 0; // &gt; Stores the previous angle.

 // Speed shoes:
 // _____________________________________________________________________________________________________________________________ 
 
    speedshoe_state = 0; // &gt; Checks if we're using the speed shoes.
    speedshoe_timer = 0; // &gt; How long speed shoes last.
    
 // Input Flags:
 // _____________________________________________________________________________________________________________________________ 
 
    input_alarm     = 0; // &gt; Input alarm, used to prevent the character from receiving input when sliding down slopes.
    input_alarm_dir = 0; // &gt; The direction that we want to lock.
    input_lock_l    = 0; // &gt; Locks input to the left.
    input_lock_r    = 0; // &gt; Locks input to the right.
    input_lock_s    = 0; // &gt; Locks input after using a spring.
    launch_lock     = 0; // &gt; Locks the horizontal speed while launching. (Depends on terrains launch method)
    tunnel_lock     = 0; // &gt; Locks the character while inside tunnels.
    flipper_lock    = 0; // &gt; Locks the character while on a flipper.
    lock_timer      = 0;
    
 // Crouching / Looking:
 // _____________________________________________________________________________________________________________________________ 
 
    up_timer   = 0; // &gt; Timer while looking up. Used for camera shifting.
    down_timer = 0; // &gt; Timer while looking down. Used for camera shifting.
    allow_look = 1; // &gt; Allows the character to crouch and look up.
    
 // Shields:
 // _____________________________________________________________________________________________________________________________ 
 
    shield_index  = 0;     // &gt; The current shield the character uses.
    shield_object = noone; // &gt; Sets the shield object.
    shield_usable = 0;     // &gt; Checks if a shield is usable (Used for special actions)
    shield_state  = 0;     // &gt; The state of the shield. 
    
 // Invincibility:
 // _____________________________________________________________________________________________________________________________ 
 
    invincibility       = 0; // &gt; Checks if the character is invulnerable to damage. (0 = No. 1 = After getting hit. 2 = Invincibility or super form)
    invincibility_timer = 0; // &gt; How long invincibility lasts.
    
 // Position:
 // _____________________________________________________________________________________________________________________________ 
 
    previous_x = 0; // &gt; Stores the previous x position.
    previous_y = 0; // &gt; Stores the previous y position.
 
 // Underwater flags:
 // _____________________________________________________________________________________________________________________________ 
 
    drown_timer   = 1800;  // &gt; how long it takes until we're drowning.
    drown_counter = noone; // &gt; Keeps track of the counter instance.
    bubble_timer  = 0;     // &gt; How long the character stays in the air after getting a air bubble.
    breath_timer  = 40;    // &gt; Used to spawn bubbles after drowning.
    has_drowned   = false; // &gt; Checks if we've drowned.
    
 // Jumping:
 // _____________________________________________________________________________________________________________________________ 
 
    jump_strength  = -6.5;  // &gt; Max. jumping strength.
    jump_release   = -4;    // &gt; Min. jumping strength.
    jump_completed = false; // &gt; Checks if the character completed their jump.
    jump_lock      = false; // &gt; Whether or not horizontal input is locked while jumping.
    
 // Rolling, Spindashing, Drop Dash and Peelout:   
 // _____________________________________________________________________________________________________________________________
  
    spindash_strength  = 0;         // &gt; Current strength of the spindash.
    spindash_pitch     = 1;         // &gt; Used to change the spindash charging sound effect.
    roll_deceleration  = 0.125;     // &gt; Base deceleration value while rolling.
    roll_friction      = 0.0234375; // &gt; Friction while we're rolling.
    roll_decel_up      = 0.078125;  // &gt; Deceleration while rolling up slopes.
    roll_decel_down    = 0.3125;    // &gt; Deceleration while rolling down slopes.  
    roll_rebounce      = false;     // &gt; Check if we fully rebounce off a enemy/monitor.
    dropdash_state     = 0;         // &gt; Current drop dash state. (0 = Null, 1 = Charging, 2 = Ready)
    dropdash_timer     = 0;         // &gt; Used to charge the drop dash.    
    dropdash_speed     = 8;         // &gt; The base speed for the drop dash.
    dropdash_max_speed = 12;        // &gt; The top speed for the drop dash.
    dropdash_trg_speed = 0;         // &gt; The vertical speed we had when we triggered the dropdash. (For more infos, check sonic_state_dropdash()
    peelout_flag       = 0;         // &gt; Used to keep the character in their figure 8 animation after performing it.
    peelout_timer      = 0;         // &gt; Used while charging the figure 8 move.
    
 // Skidding:
 // _____________________________________________________________________________________________________________________________
  
    skid_direction  = 0;  // &gt; The direction we're skidding towards.
    skid_dust_timer = 3; // &gt; How many frames it takes to spawn a new dust particle.
    
 // Pushing:
 // _____________________________________________________________________________________________________________________________
  
    push_id        = noone; // &gt; The instace we're pushing.
    push_timer     = 0;     // &gt; Used to trigger the pushing state. 
    push_timer_max = 3      // &gt; The amount of time it takes to start pushing.
    
 // Miles variables:
 // _____________________________________________________________________________________________________________________________
 
    miles_flight_timer    = 0;     // &gt; How long we've been flying.
    miles_flight_duration = 480;   // &gt; How long we can fly.
    
    miles_tail_sprite     = noone; // &gt; Sprite for Miles tail.
    miles_tail_frame      = 0;     // &gt; Current tail frame.
    miles_tail_speed      = 0;     // &gt; Animation speed for the tail. 
    miles_tail_x          = 0;     // &gt; X Position for the tail.
    miles_tail_y          = 0;     // &gt; Y Position for the tail.
    miles_tail_angle      = 1;     // &gt; Angle of the tail. 
    miles_tail_direction  = 1;     // &gt; Direction of the tail.        
    
 // Knuckles variables:
 // _____________________________________________________________________________________________________________________________
 
    glide_top_speed    = 24;    // &gt; Fastest Knuckles can move horizontally while gliding.
    glide_gravity      = 0.125; // &gt; The gravity used while gliding.
    glide_crouch_timer = 15;    // &gt; How long knuckles stays in his crouched state (after a drop)
    glide_turn_s       = 0;     // &gt; Special variable for turning knuckles sprite.
    glide_turn_a       = 0;     // &gt; ^^ 
    climb_ox           = 0;     // &gt; Position that returns the x position when grabbing. If it increases or decreases, we stop climbing.
    climb_speed        = 1;     // &gt; How fast Knuckles can climb up a wall.
   // climb_frame_timer  = 6;   // &gt; Advances the climbing frame when it reaches 0. OBSOLETE
    is_ledge_grabbing  = 0;     // &gt; Returns if we're ledge climbing.         
    
        
 // Misc.:
 // _____________________________________________________________________________________________________________________________
    
    death_timer       = -5;   // &gt; See death script in the step event. 
    afterimage_draw  = false; // &gt; Should we draw a afterimage?
    afterimage_timer = 0;     // &gt; Timer that prevents the spawning of another afterimage.

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inputs keys.
 
    input_up               = false;
    input_down             = false;
    input_right            = false;
    input_left             = false;
    input_action           = false;
    input_special          = false;
    
    input_up_pressed       = false;
    input_down_pressed     = false;
    input_right_pressed    = false;
    input_left_pressed     = false;
    input_action_pressed   = false;
    input_special_pressed  = false;    
    
    input_up_released      = false;
    input_down_released    = false;
    input_right_released   = false;
    input_left_released    = false;
    input_action_released  = false;
    input_special_released = false;    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animation variables.
 // This script will create variables for the animation system.
 // If you're curious how to use/create animations, see "tutorial_character_animations()"
  
    animation_index           = "STAND";
    animation_previous        = "";
    animation_flag            = "START";
    animation_sprite_id       = spr_sonic_stand;
    animation_speed           = 0;
    animation_rendering_speed = 0;
    animation_frame           = 0;
    animation_end             = 0;
    animation_loop            = 0;
    animation_loop_timer      = 0;
    animation_next            = "";
    animation_next_frame      = 0;
    animation_direction       = 1;
    animation_angle           = 0;
    animation_angle_mod       = 0;
    animation_blend           = c_white;
    animation_alpha           = 1;
    animation_timer           = 0; 
    draw_x                    = x;
    draw_y                    = y;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Finish initalization / Checkpoint respawn and camera.

 // Set the init. flag. Allowing other scripts to run.
    is_initialized = true;

 // Set checkpoint position.
    if(global.checkpoint_x != -1)
    {
       global.game_time = global.checkpoint_t;
       x                = global.checkpoint_x;
       y                = global.checkpoint_y;
    }
        
 // Create the camera.
    camera = instance_create(x, y, ctr_camera);
    camera . x = x;
    camera . y = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Revert wall stop.
 
    disable_wallstop = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Keep within boundaries

    if(x &lt;= (camera.limit_left+sprite_get_width(MASK_MAIN)/2) &amp;&amp; x_speed &lt; 0.0)
    {
       if(state != CS_GLIDE)
       {
          x_speed = 0;
       }
       else
       {
          if(x_speed &lt; -4) x_speed = -4;
       }
       x       = (camera.limit_left+sprite_get_width(MASK_MAIN)/2);
       if(ground)
       {
          animation_index = "IDLE";
       }
    }
    else
    if(x &gt;= (camera.limit_right-sprite_get_width(MASK_MAIN)/2) &amp;&amp; x_speed &gt; 0.0)
    {
       if(state != CS_GLIDE)
       {
          x_speed = 0;
       }
       else
       {
          if(x_speed &gt; 4) x_speed = 4;
       }
       x       = (camera.limit_right-sprite_get_width(MASK_MAIN)/2);
       if(ground)
       {
          animation_index = "IDLE";
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Trigger animation / Modify animation variables.
 // Here we change which animation should play at any time.
 
 // Set drawing cordinates:
    draw_x = x;
    draw_y = y;

 // Assign tail:
    if(character_id = CHAR_TAILS)
    {
       tail_animation_setup();
    }
    
 // Assign animation:
   
 // Standing, Idling:
    if(ground == true)
    {
       if(state == CS_DEFAULT &amp;&amp; x_speed == 0 &amp;&amp; animation_index != "SKID TURN" &amp;&amp; animation_index != "CROUCH_UP" &amp;&amp; animation_index != "LOOK_END")
       { 
          if(animation_index != "STAND" &amp;&amp;  animation_timer &lt; 288) { animation_index = "STAND";}
          if(animation_index != "BORED_1" &amp;&amp; animation_timer = 288 &amp;&amp; animation_index != "BORED_2") { animation_index = "BORED_1"; }          
       }
    }
    
 // Standing state timer, to change to idle animations.
    if(animation_index == "STAND")
    {
       if(animation_timer &lt; 288) {  animation_timer += 1; }
    }
    else
    {
       if(animation_index = "BORED_1" || animation_index = "BORED_2")
       { 
          animation_timer = 288;
       }
       else
       {
          animation_timer = 0;
       } 
    }
    
 // Change the animation speeds of the idle animations (once a certain frame has passed)
    if(animation_index == "BORED_1")
    {
       if(animation_frame &lt; 6) { animation_speed = 0.25; }
       else { animation_speed = 0.15; }
    }
 
 // Walking, Running, Dashing:
    if(state == CS_DEFAULT &amp;&amp; x_speed &lt;&gt; 0 &amp;&amp; animation_index != "SKID TURN")
    {
       if(ground == true)
       {
          if(animation_index != "WALK"  &amp;&amp; abs(x_speed) &lt; 3.75)                      
          { 
             animation_index = "WALK"; 
          }
          if(animation_index != "PEELOUT")
          {
             if(animation_index != "JOG"   &amp;&amp; abs(x_speed) &gt;= 3.75 &amp;&amp; abs(x_speed) &lt; 6 &amp;&amp; ( (animation_index == "WALK" &amp;&amp; animation_frame &gt;= 2 &amp;&amp; animation_frame &lt;= 4 || animation_index != "WALK") )) 
             { 
                animation_index =  "JOG"; 
             }          
             if(animation_index != "RUN"   &amp;&amp; abs(x_speed) &gt;= 6 &amp;&amp; abs(x_speed) &lt; 12) 
             { 
                animation_index =  "RUN";
             }      
             if(animation_index != "DASH"  &amp;&amp; abs(x_speed) &gt;= 12 ) 
             { 
                animation_index = "DASH"; 
             }
          }  
          else
          {
             if(peelout_flag == 1)
             {
                if(abs(x_speed) &gt; 8)
                {
                   animation_index = "PEELOUT";
                }
                else
                {
                   peelout_flag    = 0;
                   animation_index = "RUN";
                }
             }
          }   
       }    
    }
    
 // Set the animation speed for walk, run, dashing and peelout:
    if(ground == true &amp;&amp; animation_index != "SKID TURN")
    {
       if(animation_index == "WALK" || animation_index = "JOG")  { animation_speed = min(1, max(0.2+(abs(g_speed)*0.05))); }
       if(animation_index == "RUN" || animation_index == "DASH") { animation_speed = 0.35+abs(x_speed)/25; }
       if(animation_index == "PEELOUT")
       {
          if(x_speed == 0)
          {
             animation_speed = 0.35+abs(12)/25;
          }
          else
          {
             animation_speed = 0.35+abs(x_speed)/25;
          }
       }
    }
    
 // Set the peelout animation (while charging):
    if(state == CS_PEELOUT)
    {
       if(peelout_timer &lt; 16)
       {
          animation_index = "WALK";
       }
       else if(peelout_timer &gt;= 16 &amp;&amp; peelout_timer &lt; 32)
       {
               animation_index = "RUN"
       }
       else if(peelout_timer &gt;= 32)
       {
               animation_index = "PEELOUT";
       }
   } 
          
 // Looking up / Crouching.
    if(state == CS_LOOK)
    {
       if(animation_index != "LOOK") { animation_index = "LOOK"; }
    } 
    if(state == CS_CROUCH)
    {
       if(animation_index != "CROUCH") { animation_index = "CROUCH"; }
    }
         
 // Jumping / Rolling:
    if(state == CS_JUMP &amp;&amp; dropdash_state != 2 || state == CS_ROLL)
    {
       if(animation_index != "ROLL") { animation_index = "ROLL"; }
    }
 // Align the rolling sprites.
    if(state == CS_ROLL &amp;&amp; ground == true)
    {
       align_roll_animation();
    }    
 // Set the animation speed for rolling:
    if(state == CS_JUMP) { animation_speed = animation_rendering_speed; } 
    if(state == CS_ROLL &amp;&amp; ground == true) 
    {
       animation_speed           = 0.25+abs(x_speed)/12;
       animation_rendering_speed = animation_speed;
    }
    else if(state == CS_ROLL &amp;&amp; ground == false)
    {
            animation_rendering_speed = animation_speed;    
    }
 
 // Spindash.
    if(state == CS_SPINDASH)
    {
       if(animation_index != "SPINDASH") { animation_index = "SPINDASH"; }
    }    
    
 // Dropdash.
    if(state == CS_JUMP &amp;&amp; dropdash_state == 2)
    {
       if(animation_index != "DROPDASH") { animation_index = "DROPDASH"; }
    }   
    
 // Spring.
    if(state == CS_SPRING_DIAGONAL &amp;&amp; y_speed &lt;= 0)
    {
       if(animation_index != "SPRING") { animation_index = "SPRING"; }
    }
    else if(state == CS_SPRING_DIAGONAL &amp;&amp; y_speed &gt; 0)    
    {
       if(animation_index != "WALK") { animation_index = "WALK"; }    
    }    
 // Spring Twirl.
    if(state == CS_SPRING &amp;&amp; y_speed &lt;= 0)
    {
       if(animation_index != "TWIRL") { animation_index = "TWIRL"; }
    }
    else if(state == CS_SPRING &amp;&amp; y_speed &gt; 0)    
    {
       if(animation_index != "WALK") { animation_index = "WALK"; }    
    }
 
 // Pushing:
    if(state == CS_PUSH)
    {
       if(animation_index != "PUSH") { animation_index = "PUSH"; }
    }   
        
 // Hurt.
    if(state == CS_HURT)
    {
       if(animation_index != "HURT") { animation_index = "HURT"; }
    }
    
 // Death / Drown.
    if(state == CS_DEATH)
    {
       if(physic_state == 0)
       {
          animation_index = "DEATH";
       }
       else
       {
          animation_index = "DROWN";
       }
    }
    
 // Flying / Swimming.
    if(state == CS_FLY)
    {
       if(physic_state == 0)
       {
          if(animation_index != "FLY") { animation_index = "FLY"; }
       }
       else
       {
          if(animation_index != "SWIM") { animation_index = "SWIM"; }       
       }
    }
    if(state == CS_FLYDROP)
    {
       if(physic_state == 0)
       {
          if(animation_index != "FLY DROP") { animation_index = "FLY DROP"; }
       }
       else
       {
          if(animation_index != "SWIM DROP") { animation_index = "SWIM DROP"; }       
       }
    }    
    
 // Gliding.
    if(state == CS_GLIDE &amp;&amp; animation_index != "GLIDE" &amp;&amp; animation_index != "GLIDE TURN" &amp;&amp; animation_index != "GLIDE TURN END" &amp;&amp; !ground)
    {
        animation_index = "GLIDE";
    } 
              
 // Glide drop.
    if(state == CS_GLIDE_DROP &amp;&amp; animation_index != "GLIDE DROP" &amp;&amp; !ground)
    {
       animation_index = "GLIDE DROP";
    } 
    
 // Climbing.
    if(state == CS_CLIMB &amp;&amp; is_ledge_grabbing == 0)
    {
       if(y_speed == 0)
       {
          if(animation_index != "CLIMB")
          {
             animation_index = "CLIMB";
          }
       }
       if(y_speed &gt; 0)
       {
          if(animation_index != "CLIMB DOWN")
          {
             animation_index = "CLIMB DOWN";
          }
       }     
       if(y_speed &lt; 0)
       {
          if(animation_index != "CLIMB UP")
          {
             animation_index = "CLIMB UP";
          }
       }              
    }
    else if(state == CS_CLIMB &amp;&amp; is_ledge_grabbing == 1) 
    {
           if(animation_index != "CLIMB LEDGE")
           {
              animation_index = "CLIMB LEDGE";
           }
    }
    
 // Slide.
    if(state == CS_SLIDE)
    {
       if(animation_index != "SLIDE")
       {
          animation_index = "SLIDE";
       }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animation system.
 // Plays and updates the animation state of the character.
 
    if(is_initialized)
    { 
       if(animation_index != "") // Check if there's a animation to play.
       {
          // Check if we changed our animation and (re)start playback:
             if(animation_index != animation_previous)
             {
                animation_previous = animation_index;
                animation_flag     = "START";
                animation_frame    = 0;
             }
             
          // Start the playback of the animation:
             if(animation_flag == "START")
             {
                update_animation_index();
                animation_flag = "PLAY";
             }

          // Play the animation:
             if(animation_flag == "PLAY")
             {
                // Animate:
                   animation_frame += animation_speed;
                
                // Check if the animation has ended:                   
                   if(floor(animation_frame) &gt; animation_end)
                   { 
                      // See if the animation loops indefinitely:
                         if(animation_loop != -1)
                         {
                            // Revert back to starting frame:
                               if(animation_loop_timer == -1)
                               {
                                  animation_frame = animation_loop;
                               }
                               else // Repeat the animation a certain amount of times.
                               {
                                    if(animation_loop_timer &gt; 1)
                                    {
                                       animation_loop_timer -= 1;
                                       animation_frame       = animation_loop;
                                    }
                                    else // End playback.
                                    {
                                       animation_frame = animation_end;                            
                                       animation_flag  = "END";                                    
                                    }
                               }
                         } 
                         else // End playback.
                         {
                            animation_frame = animation_end;    
                            animation_flag  = "END";                     
                         }
                   }
             }
             // End animation playback / Switch to animation:
             if(animation_flag == "END")
             {
                if(animation_next != "")
                {
                   animation_flag  = "PLAY";                  
                   animation_index = animation_next; 
                   animation_frame = animation_next_frame;                                                    
                   update_animation_index();                                                  
                }
             }
       }
    }    
   
 // Tail animation speed. 
    if(miles_tail_sprite != noone)
    {
       miles_tail_frame += miles_tail_speed;
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animation Direction.
 // Defines how the facing direction changes per animation.
 
 // Change direction depending on input and speed:
    if(state != CS_SPINDASH &amp;&amp; state != CS_LOOK    &amp;&amp; state != CS_CROUCH
    &amp;&amp; state != CS_ROLL     &amp;&amp; state != CS_SKID    &amp;&amp; state != CS_JUMP
    &amp;&amp; state != CS_HURT     &amp;&amp; state != CS_PEELOUT &amp;&amp; state != CS_CLIMB)
    {
          if(input_left  &amp;&amp; x_speed &lt;= 0) { animation_direction = -1; }
          if(input_right &amp;&amp; x_speed &gt;= 0) { animation_direction =  1; }
    }

 // Skid Turn:
    if(animation_index == "SKID TURN")
    {
       if(x_speed &gt; 0) { animation_direction = -1; }
       if(x_speed &lt; 0) { animation_direction =  1; }
    }
    
 // Rolling direction:
    if(state == CS_ROLL)
    {
       // Change direction depending on input and speed:            
          if(x_speed &gt; 0 &amp;&amp; input_right) { animation_direction  =  1; }
          if(x_speed &lt; 0 &amp;&amp; input_left)  { animation_direction  = -1; }         
    }

 // Jumping direction:
    if(state == CS_JUMP &amp;&amp; !jump_lock || state == CS_SPRING || state == CS_SPRING_DIAGONAL)
    {
      // Change direction depending on input:
         if(input_right) { animation_direction =  1; } 
         if(input_left)  { animation_direction = -1; }
         if(input_left &amp;&amp; input_right)
         {
            animation_direction = animation_direction;
         }
    }

  // Change direction in the air:
     if(!ground &amp;&amp; state = CS_DEFAULT)
     {     
        // Change direction depending on input:
           if(input_right) { animation_direction =  1; }  
           if(input_left)  { animation_direction = -1; }                         
     } 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite rotation.
 // This is used for rotating the players sprite.
 
 // Exit if not initialized, death or hurt.
    if(is_initialized == true &amp;&amp; state != CS_DEATH &amp;&amp; state != CS_HURT &amp;&amp; state != CS_FLY &amp;&amp; state != CS_FLYDROP &amp;&amp; state != CS_GLIDE &amp;&amp; state != CS_CLIMB &amp;&amp; state != CS_GLIDE_DROP &amp;&amp; state != CS_CROUCH &amp;&amp; state != CS_LOOK)
    {
 
 // Change animation angle values:
    if(ground)
    {
       if(f_angle_change == 0)
       {       
          animation_angle_mod = 0;
       }
       else
       {
          var _angMod;
          _angMod = animation_angle_mod;
             
          if(angle &gt;= 0 &amp;&amp; angle &lt;= 180)
          {
             if(angle &lt; 36)
             {
                _angMod = 0;
             }
                else
             {
                _angMod = angle;
             }
          }
          if(angle &gt;= 180 &amp;&amp; angle &lt;= 360)
          {
             if(angle &gt; 360-36)
             {
                _angMod = 0;
             }
             else
             {
                _angMod = angle;
             }
          }
          if(abs(angle_difference(animation_angle_mod, _angMod))&lt;45)
          {
             animation_angle_mod = rotate_towards(_angMod, animation_angle_mod, max(4, abs(x_speed)));
          }
          else
          {
             animation_angle_mod = _angMod;
          }
       } 
    }
    else
    {
       animation_angle_mod = rotate_towards(0, animation_angle_mod, 4)
    }
 
 // Rotate:   
    if(global.setting_gameplay_rotation == 0)
    { 
       animation_angle  = round(animation_angle_mod/45)*45;
       miles_tail_angle = round(animation_angle_mod/45)*45;
    }
    else if(global.setting_gameplay_rotation == 1)
    {
       animation_angle  = animation_angle_mod;
       miles_tail_angle = animation_angle_mod;    
    } 
    
 // Set angle to zero and exit if we're not using a animation that can be rotated.
    if(animation_index == "STAND" || animation_index = "ROLL" || animation_index = "HURT" || animation_index = "SPRING" || animation_index = "TWIRL") 
    {
       animation_angle = 0;
    }

    }
    else
    {
       animation_angle = 0;
    }
    
 // Set the Angle of Miles tail.
    if((state = CS_JUMP || state = CS_ROLL || animation_index = "ROLL"))
    {
        if(ground == false)
        {
           if(global.setting_gameplay_rotation == 1)
           {
              miles_tail_angle = point_direction(xprevious, yprevious, x, y);
              if(miles_tail_direction != 1)
              {
                 miles_tail_direction = 1;
              }
           }
           else
           {
              miles_tail_angle = round(point_direction(xprevious, yprevious, x, y)/45)*45;          
              if(miles_tail_direction != 1)
              {
                 miles_tail_direction = 1;
              }
           }
        }
    }       
 
 // Set the Tail direction.
    if(ground)
    {
       if(x_speed &lt;&gt; 0)
       {
          miles_tail_direction = sign(x_speed);
       }
       else miles_tail_direction = animation_direction;
    }
    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Water splash.

    if(global.zone_water_position != -1)
    {
       if ((abs(y_speed) &gt;= 0)
       &amp;&amp; ((y &gt; global.zone_water_position &amp;&amp; previous_y &lt; global.zone_water_position)
       ^^  (y &lt; global.zone_water_position &amp;&amp; previous_y &gt; global.zone_water_position)))
       {
           dummy_effect_create(spr_water_splash, 0.3, x, global.zone_water_position-8, -999995, 0);
           audio_play(_general_water_splash, global.sfx_volume);    
           character_handle_watersurface();      
       }
    }

    
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Visual Effects.

 // Afterimage. (Speedshoes, Invincibility)
    if(afterimage_draw == true)
    {
       if(afterimage_timer == 0 &amp;&amp; instance_number(obj_character_afterimage) &lt; 3)
       {
          afterimage_timer = 6;
          with(instance_create(floor(draw_x), floor(draw_y), obj_character_afterimage))
          {
               sprite_index = other.animation_sprite_id;
               image_xscale = other.animation_direction;
               image_yscale = 1;
               image_angle  = other.animation_angle;
               image_speed  = 0;
               image_index  = floor(other.animation_frame);
               image_alpha  = 0.9;
               depth        = other.depth+1;
          }
       }
       if(afterimage_timer &gt; 0)
       {
          afterimage_timer -= 1;
       }
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Receive Inputs.
 
    character_input_check();

 // Disable input if both left and right is being held.
    if(input_left &amp;&amp; input_right)
    {
       input_left  = false;
       input_right = false;
    }
    
 // Input alarm.
    if(input_alarm)
    {
       if(input_alarm_dir == 1)
       {
          input_right = false;
       }
       if(input_alarm_dir == -1)
       {
          input_left = false;
       }
    }
    
 // Input locks (spring)
    if(input_lock_l)
    {
       input_left = false;
    }
    if(input_lock_r)
    {
       input_right = false;
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change Physics / Previous Position.

 // Previous Positions:
    previous_x = x;
    previous_y = y;
    
 // Switch Physic Modes:
    if(global.zone_water_position != -1)
    {
       if(y &lt; global.zone_water_position)
       {
          if(physic_state != 0)
          {
             physic_state = 0
          }
       } 
       if(y &gt; global.zone_water_position)
       {
          if(physic_state != 1)
          {
             physic_state = 1;
          }   
       }   
    }

 // Get physic value:
    if(character_id == CHAR_SONIC)
    {
       physics_get_sonic();
    }
    if(character_id == CHAR_TAILS)
    {
       physics_get_miles();
    }
    if(character_id == CHAR_KNUX)
    {
       physics_get_knuckles();
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Death.

    if(death_timer != -1)
    {
       if(state == CS_DEATH)
       {
          // Trigger death state. (Set actual timer and throw the character into the air (if not underwater))
             if(death_timer == -5)
             {
                global.add_time = false;
                if(physic_state == 0)
                {  
                   y_speed = -7;
                }
                angle       = 0;
                death_timer = 128;
                depth       = -999995;
                
                // Fade out the background music.
                   with(ctr_audio)
                   {
                        fadeout_flag = 1;
                   }
                   
                // Decrease lives:
                   global.clives -= 1;
                   if(global.clives &lt; 0) global.clives = 0;
                   
                // Play death/drown sound.
                   if(has_drowned == false)
                   {
                      audio_play(_char_hurt, global.sfx_volume);
                   }
                   else
                   {
                      audio_play(_char_drown, global.sfx_volume);
                   }
                
                // Destroy shields.
                   shield_index = 0;     
                   
                // Stop sound effects.
                   if(audio_is_playing(_char_flying) == true)
                   {
                      audio_stop(_char_flying);
                   }  
                   if(audio_is_playing(_char_flying_tired) == true)
                   {
                      audio_stop(_char_flying_tired);
                   }                              
             }
             
          // Gravity:
             if(physic_state == 0)
             {
                y_speed += 0.21875;
             }
             else
             {
                y_speed += 0.0625;
             }
             y += y_speed;
             
          // Decrease timer.
             if(death_timer &gt; 0)
             {
                death_timer -= 1;
             }
             else if(death_timer == 0)
             {
                     death_timer = -1;
                     if(global.clives != 0)
                     {
                        with(instance_create(0, 0, obj_fade_to))
                        {
                             fade_to = room;
                        }
                     }
                     else
                     {
                        with(instance_create(0, 0, obj_fade_to))
                        {
                             fade_to = rm_menu;
                        }                                             
                        global.checkpoint_x = -1;
                        global.checkpoint_y = -1;
                        global.checkpoint_t =  0;  
                     }
             }
       }
    }

 // Trigger death by reaching the death position. 
    if(global.death_trigger_position != -1)
    {
       if(y &gt;= global.death_trigger_position)
       {
          if(state != CS_DEATH)
          {
             state = CS_DEATH;
          }
       }
    }
    else
    {
       if(y &gt;= room_height)
       {
          if(state != CS_DEATH)
          {
             state = CS_DEATH;
          }
       }    
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Collision &amp; Instance Detection.
 // Handles how the character interacts with collision and instances.

 // Only run this script if the character has not died and is initialized.
    if(is_initialized &amp;&amp; state != CS_DEATH)
    {
    
       // Slope fix for platforms:
       /*
          It was possible to jump-through sloped platforms due to the collision check, checking if the character is actually on ground-
          This additional collision check will fix this issue by setting a flag once the character is near the platform.
       */
          if(character_collision_check(COL_SLOPE_PLATFIX, spr_mask_platform_checker, x, y, angle))
          {
             platform_mode = 1;
          }
          else
          {
             platform_mode = 0;
          }    
                                 
       // Horizontal block:
       
       // Set temp. variable for samples:
          var _samples, _steps;
          
       // Limit the characters horizontal speed.
          if(x_speed_limit == true)
          {
             x_speed = clamp(x_speed, -x_speed_max, x_speed_max);
          }
          
       // Set samples:
          _steps = 1;
          if(x_sample &gt; 0)
          {
             _steps += floor(abs(x_speed)/x_sample);
          }
          _samples = x_speed/_steps;
       
       // Interact horizontally:
          repeat(_steps)
          {
                 // Set Position according to angle.
                    x += dcos(angle)*_samples;
                    y -= dsin(angle)*_samples;
                    
                 // Move the character outside of terrain, if stuck.
                    while(_samples &gt; 0 &amp;&amp; (character_collision_check(COL_RIGHT, MASK_MID, x, y, angle) == true))
                    { 
                          x -= dcos(angle);
                          y += dsin(angle);
                    }
                    while(_samples &lt; 0 &amp;&amp; (character_collision_check(COL_LEFT, MASK_MID, x, y, angle) == true))
                    { 
                          x += dcos(angle);
                          y -= dsin(angle);
                    }
                    
                 // Handle instances:
                    character_handle_ring();
                    character_handle_spring();                  
                    character_handle_monitor(); 
                    character_handle_badnik();
                    character_handle_layer();
                    character_handle_hurt();
                    character_handle_platforms();          
                    character_handle_spikes();   
                    character_handle_tunnels();            
                    
                 // Terrain / Slopes:                 
                    if(ground == true)
                    {
                       while(character_collision_check(COL_MAIN, x, y))
                       {
                             x -= dsin(angle);
                             y -= dcos(angle);
                       }
                       if(character_collision_check(COL_SLOPE, MASK_MID, x, y, angle))
                       {
                          while(!character_collision_check(COL_MAIN, x, y))
                          {
                                x += dsin(angle);
                                y += dcos(angle);
                          }
                       }
                       
                       // Receive new angles:
                          if(y_allow == true)
                          {
                             if(f_edge_skip == 0)
                             {
                                if(character_collision_check(COL_LEFT_EDGE, x, y, angle) &amp;&amp; character_collision_check(COL_RIGHT_EDGE, x, y, angle))
                                {
                                   if(f_edge_exception == 1)
                                   {
                                      angle_test = character_calculate_angle(x, y, angle);
                                      if(angle_test &gt;= 60 &amp;&amp; angle_test &lt;= 90 || angle_test &gt;= 240 &amp;&amp; angle_test &lt;= 300)
                                      {
                                         if(!character_collision_check(COL_EDGE_LINE))
                                         {  
                                            audio_play(_general_ring, global.sfx_volume);      
                                            ground = false;                                         
                                            break;
                                         }
                                         else angle = angle_test;
                                      }   
                                   }
                                   else angle = character_calculate_angle(x, y, angle);                          
                                }
                             }
                             else
                             {
                                   if(f_edge_exception == 1)
                                   {
                                      angle_test = character_calculate_angle(x, y, angle);
                                      if(angle_test &gt;= 60 &amp;&amp; angle_test &lt;= 90 || angle_test &gt;= 240 &amp;&amp; angle_test &lt;= 300)
                                      {
                                         if(!character_collision_check(COL_EDGE_LINE))
                                         {  
                                            audio_play(_general_ring, global.sfx_volume);      
                                            ground = false;                                         
                                            break;
                                         }
                                         else angle = angle_test;
                                      }   
                                   }
                                   else angle = character_calculate_angle(x, y, angle); 
                             }
                          }
                    }
                    
                 // Handle instances:
                    character_handle_ring();                 
                    character_handle_spring();                   
                    character_handle_monitor();
                    character_handle_badnik();
                    character_handle_layer();
                    character_handle_hurt();
                    character_handle_platforms(); 
                    character_handle_spikes();
                    character_handle_tunnels();                                                               
                                                            
                 // Abort:
                    if(x_speed == 0)
                    {
                       break;
                    }   
          }
          
       // Vertical block:
       
       // Set temp. variable for samples:
          var _ysamples, _ysteps;
          
       // Limit the characters horizontal speed.
          if(y_speed_limit == true)
          {
             y_speed = clamp(y_speed, -y_speed_max, y_speed_max);
          }
          
       // Set samples:
          if(ground == false)
          {
             _ysteps = 1;
             if(y_sample &gt; 0)
             {
                _ysteps += floor(abs(y_speed)/y_sample);
             }
             _ysamples = y_speed/_ysteps;      
          } 
     
       // Interact vertically:          
          if(ground == false)
          {
             repeat(_ysteps)
             {
                 // Set Position according to angle.
                    x += dsin(angle)*_ysamples;
                    y += dcos(angle)*_ysamples;
                    
                 // Move the character outside of terrain, if stuck.
                    while(_ysamples &lt; 0 &amp;&amp; (character_collision_check(COL_TOP, MASK_MID, x, y, 0) == true)) 
                    {
                          x += dsin(angle);
                          y += dcos(angle);
                    }
                    while(_ysamples &gt; 0 &amp;&amp; (character_collision_check(COL_BOTTOM, MASK_MID, x, y, 0) == true))
                    {
                          x -= dsin(angle);
                          y -= dcos(angle);
                    }       
                    
                 // Handle instances:   
                    character_handle_ring();                 
                    character_handle_spring();                   
                    character_handle_monitor(); 
                    character_handle_badnik();
                    character_handle_layer();
                    character_handle_hurt();   
                    character_handle_platforms();  
                    character_handle_spikes();  
                    character_handle_tunnels();                                                                             
                                                                             
                 // Check for landing on terrain:
                    if(y_speed &gt;= 0 &amp;&amp; character_collision_check(COL_BOTTOM, MASK_BIG, x, y, 0))
                    {
                       // Set new angles:
                          if(f_edge_skip == 0)
                          {
                             if(character_collision_check(COL_LEFT_EDGE, x, y, 0) &amp;&amp; character_collision_check(COL_RIGHT_EDGE, x, y, 0))
                             { 
                                character_set_angle(character_calculate_angle(x, y, angle));
                             } 
                             else
                             {
                                character_set_angle(0);
                             }
                          }
                          else
                          {
                                character_set_angle(character_calculate_angle(x, y, angle));                          
                          }
                          
                       // Check if we landed on obstacles:
                          if(character_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_obstacle))
                          {
                             character_set_angle(0);
                          }
                          
                       // Change horizontal speed once we landed on terrain.
                          if(abs(x_speed) &lt;= abs(y_speed) &amp;&amp; angle_relative &gt;= 22.5 &amp;&amp; angle_relative &lt;= 337.5)
                          {
                             x_speed = -y_speed*sign(dsin(angle_relative));
                             if(angle_relative &lt; 45 || angle_relative &gt; 315)
                             {
                                x_speed *= 0.5;
                             }
                          }
                          
                       // Set ground flag:
                          y_speed = 0;
                          ground  = true;
                          
                       // Return to the default state.
                          if(state != CS_GLIDE &amp;&amp; state != CS_GLIDE_DROP &amp;&amp; state != CS_SLIDE)
                          {
                             if(state != CS_HURT || state != CS_JUMP)
                             {
                                state = CS_DEFAULT;
                             }
                          }
                          
                       // Return to normal state after flying.
                          if(state == CS_FLY || state == CS_FLYDROP)
                          {
                             state          = CS_DEFAULT;
                             y_acceleration = y_common_acceleration;
                          }                  
                    }  
                    
                 // Check for ceiling:
                    if((y_speed &lt; 0 &amp;&amp; character_collision_check(COL_TOP, MASK_LARGE, x, y, 0)) &amp;&amp; (!character_collision_check(COL_TOP_OBJECT, MASK_LARGE, x, y, angle, par_obstacle)))
                    {
                       // Set new angle.
                          character_set_angle(180);
                          
                       // Check if it's possible to land on the ceiling:
                          if(character_collision_check(COL_LEFT_EDGE, x, y, angle) &amp;&amp; character_collision_check(COL_RIGHT_EDGE, x, y, angle))
                          {
                             // Calculate new angle:
                                character_set_angle(character_calculate_angle(x, y, angle));
                                
                             // If the angle is flat, revert angle back to 0.
                                if(angle_relative &gt; 160 &amp;&amp; angle_relative &lt; 200)
                                {
                                   character_set_angle(0);
                                   y_speed = 0;
                                }
                          
                             // If the angle is not flat, change movement values:
                                x_speed -= dsin(angle)*y_speed
                                
                             // Force y speed to 0.
                                y_speed = 0;
                                
                             // Set ground flag.
                                if(ground == false &amp;&amp; angle != 0 &amp;&amp; state != CS_FLY &amp;&amp; state != CS_FLYDROP)
                                {
                                   ground = true;
                                   if(state != CS_DEFAULT)
                                   {
                                      state = CS_DEFAULT;
                                   }
                                }
                                
                             // Reset if the tile has the ceiling movement flag set to 0.
                                if(f_ceiling_movement == 0)
                                {
                                   if(x_speed &lt;&gt; 0)
                                   {
                                      x_speed = 0;
                                   }
                                   y_speed = 0;
                                   character_set_angle(0);
                                   if(ground == true)
                                   {
                                      ground = false;
                                   }
                                }
                          }
                          else
                          {
                             // Set angle to 0.
                                character_set_angle(0);
                                y_speed = 0;
                                if(ground == false)
                                {
                                   break;
                                }
                          }
                    }
                    
                 // Do another stuck check to prevent any lasting glitches that might occur.
                    while(character_collision_check(COL_RIGHT, MASK_MID, x, y, angle))
                    {
                          x -= dcos(angle);
                          y += dsin(angle);
                    }                   
                    while(character_collision_check(COL_LEFT, MASK_MID, x, y, angle))
                    { 
                          x += dcos(angle);
                          y -= dsin(angle);
                    }
                    
                 // Handle instances:   
                    character_handle_ring();                 
                    character_handle_spring();                   
                    character_handle_monitor(); 
                    character_handle_badnik();
                    character_handle_layer();   
                    character_handle_hurt(); 
                    character_handle_platforms();    
                    character_handle_spikes();  
                    character_handle_tunnels();                                                                                           
                                        
                 // Abort:
                    if(y_speed == 0)
                    {
                       break;
                    }       
             }
          }  
          
       // Fall / Launch of the tile if the edges are no longer colliding:
          repeat(_steps*2)
          {
                 if(ground == true &amp;&amp; (angle != 0 &amp;&amp; ((x_speed &lt;= 0 &amp;&amp; character_collision_check(COL_LEFT_EDGE, x, y, angle) == false) || (x_speed &gt;= 0 &amp;&amp; character_collision_check(COL_RIGHT_EDGE, x, y, angle) == false))))
                 { 
                    // Launch off slopes:
                       if(f_launch_allow == 1)
                       {
                          if((((angle != 90) &amp;&amp; (angle != 270) &amp;&amp; (angle != 180)) &amp;&amp; f_launch_angle != -1) &amp;&amp; (sign(x_speed) == f_launch_direction &amp;&amp; f_launch_direction != 0))
                          {                                                           
                             // Disable stopping at Walls to properly launch.  
                                disable_wallstop = true;
                                if(alarm[0] == -1)
                                {
                                   alarm[0] = 15;
                                }      
                               
                             // Force new angles:
                                angle_relative = sign(x_speed)*f_launch_angle;
                                angle          = sign(x_speed)*f_launch_angle;
                
                             // Set horizontal and vertical speeds:
                                y_speed = -dsin(angle_relative)*x_speed;
                                x_speed =  dcos(angle_relative)*x_speed;
                             
                             // Disable ground flag:
                                ground = false;
                                                                           
                             // Reforce new angles just to make sure nothing changes trying to launch:
                                angle_relative = sign(x_speed)*f_launch_angle;
                                angle          = sign(x_speed)*f_launch_angle;                                                            
                          }         
                          else // Fall off tile:
                          {
                                  ground  = false;
                                  y_speed = -(dsin(angle)*x_speed);
                                  x_speed =  (dcos(angle)*x_speed);
                          } 
                       }                            
                 }
          }
          
       // Receive ground speed:
          character_get_groundspeed();
    }  

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Horizontal Movement.
 // Handles how the character moves and acts horizontally.
 
 // Only run this script if the character has not died and is initialized.
    if(is_initialized &amp;&amp; state != CS_DEATH)
    {
      
       // Ignore left and right input on alarm.
          if(input_alarm != 0)
          { 
             input_alarm -= 1;
          }
          else // Revert alarm.
          {
             input_alarm     = 0;
             input_alarm_dir = 0;
          }
          
       // Revert input alarm if the angle equals 0.
          if(input_alarm != 0 &amp;&amp; angle == 0)
          {
             input_alarm     = 0;
             input_alarm_dir = 0;
          }
          
       // Store Acceleration and deceleration values.
          if(ground == true)
          {
             x_temp_accel    = x_acceleration;
             x_temp_decel    = x_deceleration;
             x_temp_friction = x_temp_accel;
          }
          else
          {
             x_temp_accel    = x_acceleration * 2;
             x_temp_decel    = 0;
             x_temp_friction = 0;
          }
          
       // Run only if x movement is possible.
          if(x_allow = true)
          {
          
             // Decelerate on slopes:
                if(state != CS_SLIDE)
                {
                   if(state == CS_ROLL &amp;&amp; ground == true)
                   {
                      // Rolling up a slope:
                         if((angle_relative &lt; 180 &amp;&amp; x_speed &gt; 0) || (angle_relative &gt; 180 &amp;&amp; x_speed &lt; 0))
                         {
                            x_speed -= dsin(angle_relative)*roll_decel_up;
                         }
                         else // Rolling down a slope:
                         {
                            x_speed -= dsin(angle_relative)*roll_decel_down;
                         }
                   }
                   else // Decelerate normally.
                   {
                           if(ground == true &amp;&amp; ((angle_relative &gt; 35 &amp;&amp; angle_relative &lt; 330) || round(x_speed) != 0 || input_alarm != 0))
                           {
                              x_speed -= dsin(angle_relative)*0.125;
                           }
                   }
                }
                
             // Handle Acceleration/Deceleration.
                if((state == CS_DEFAULT || state == CS_BALANCE || (state == CS_JUMP &amp;&amp; !jump_lock) || state == CS_SKID || state == CS_SPRING || state == CS_SPRING_DIAGONAL || state == CS_FLY || state == CS_FLYDROP || state == CS_GLIDE_DROP) &amp;&amp; (state != CS_GLIDE &amp;&amp; state != CS_SLIDE &amp;&amp; state != CS_CLIMB))
                {
                   if((ground == true))
                   {
                      if(input_left == true &amp;&amp; input_alarm == 0)
                      {
                         if(x_speed &gt; 0)
                         {
                            x_speed -= x_temp_decel;
                            if(x_speed &lt;= 0)
                            {
                               x_speed = -0.5;
                            }
                         }
                         else
                         {
                            if(x_speed &gt; -x_speed_top)
                            {
                               x_speed -= x_temp_accel;
                               if(x_speed &lt;= -x_speed_top)
                               {
                                  x_speed = -x_speed_top;
                               }                               
                            }
                         }
                      }
                      else if(input_right == true &amp;&amp; input_alarm == 0)
                      {
                              if(x_speed &lt; 0)
                              {
                                 x_speed += x_temp_decel;
                                 if(x_speed &gt;= 0)
                                 {                                 
                                    x_speed = 0.5;
                                 }   
                              }
                              else
                              {
                                 if(x_speed &lt; x_speed_top)
                                 {
                                    x_speed += x_temp_accel;
                                    if(x_speed &gt;= x_speed_top)
                                    {
                                       x_speed = x_speed_top;
                                    }
                                 }
                              }
                      }
                      else if(input_alarm == 0)
                      {
                              x_speed -= min(abs(x_speed), x_temp_friction)*sign(x_speed);
                      }
                   }
                   else
                   {
                      // Air acceleration:
                         if(input_right == true)
                         {
                            if(state == CS_FLY || state == CS_FLYDROP || state == CS_GLIDE_DROP)
                            {
                               if(x_speed &lt; 0)
                               {
                                  x_speed += x_temp_accel;
                               }
                               else if(x_speed &lt; x_speed_top)
                               {
                                       x_speed += x_air_accel;
                               }                      
                            }
                            else
                            {                         
                               x_speed += x_air_accel; 
                            }
                         }
                         if(input_left == true)
                         {
                            if(state == CS_FLY || state == CS_FLYDROP || state == CS_GLIDE_DROP)
                            {
                               if(x_speed &gt; 0)
                               {
                                  x_speed -= x_temp_accel;
                               }
                               else if(x_speed &gt; -x_speed_top)
                               {
                                       x_speed -= x_air_accel;
                               }                      
                            }
                            else
                            {                         
                               x_speed -= x_air_accel; 
                            }
                         }
                   }
                }  
                               
             // Fall if there isn't enough speed to stay on ground.
                if(angle_relative &gt;= 44 &amp;&amp; angle_relative &lt;= 315 &amp;&amp; ground == true &amp;&amp; abs(x_speed) &lt; 2.5 &amp;&amp; tunnel_lock == 0)
                {
                   if(angle_relative &gt;= 90 &amp;&amp; angle_relative &lt;= 270)
                   {
                      y_speed = -dsin(angle_relative)*x_speed;
                      x_speed =  dcos(angle_relative)*x_speed;
                      ground  =  false;
                   }
                   else // Input alarm:
                   {
                      input_alarm = 30;
                      if(input_alarm_dir == 0)
                      {
                         input_alarm_dir = animation_direction;
                      }
                   }
                }  
                               
             // Get new angle:
                if(ground &amp;&amp; character_collision_check(COL_LEFT_EDGE, x, y, angle) &amp;&amp; character_collision_check(COL_RIGHT_EDGE, x, y, angle))
                {
                   character_set_angle(character_calculate_angle(x, y, angle));
                }                     
                else
                {
                   character_set_angle(0);
                }
                
             // Full stop when we're colliding with a wall:
                if(!disable_wallstop)
                {
                   if((x_speed &gt; 0 &amp;&amp; character_collision_check(COL_RIGHT, MASK_BIG, x, y, angle)) || (x_speed &lt; 0 &amp;&amp; character_collision_check(COL_LEFT, MASK_BIG, x, y, angle)))
                   {
                      x_speed = 0;
                   }
                }
          }
    
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertical Movement.
 // Handles how the character moves and acts vertically.
  
 // Only run this script if the character has not died and is initialized.
    if(is_initialized &amp;&amp; state != CS_DEATH)
    {
       // Run only if y movement is possible.
          if(y_allow == true)
          {               
             // Return to a normal state.
                if(ground == true)
                {       
                   if not(y_speed &lt; 0 || state == CS_HURT)
                   {
                          y_speed = 0;
                   }                               
                   if(state == CS_HURT || state == CS_SPRING || state == CS_SPRING_DIAGONAL)
                   {
                      if(state == CS_HURT)
                      {
                         x_speed = 0;
                      }
                      state = CS_DEFAULT;
                   }
                   
                   // Check if the character has not landed:
                      if(character_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle) == false)
                      {
                         ground = false;
                         character_set_angle(0);
                      }
                }
                
             // Add gravity and landing checks:
                if(ground == false)
                {
                   // Gravity:
                      y_speed += y_acceleration;
                   
                   // Check if we've landed on a tile:
                      if(y_speed &gt;= 0 &amp;&amp; character_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle) == true)
                      {
                         // We are grounded.
                            ground = true;
                            
                         // Return to a normal state. 
                            if(state != CS_GLIDE &amp;&amp; state != CS_GLIDE_DROP &amp;&amp; state != CS_SLIDE)
                            {
                               if(state == CS_JUMP || state == CS_FLY || state == CS_FLYDROP || state == CS_HURT)
                               {
                                  if(state == CS_HURT)
                                  {
                                     x_speed = 0;
                                  }
                                  state = CS_DEFAULT;
                               }
                            }
                      }
                      
                   // Check if we colliding with a ceiling. 
                      if(y_speed &lt; 0 &amp;&amp; character_collision_check(COL_TOP, MASK_BIG, x, y, angle) == true)
                      {
                         y_speed = 0;
                         if(state == CS_DEFAULT &amp;&amp; x_speed == 0 &amp;&amp; y_speed == 0)
                         { 
                            state = CS_ROLL;
                         }
                      }
                }
                
             // Reset horizontal speed after getting hurt.
                if(y_speed &gt;= 0 &amp;&amp; character_collision_check(COL_BOTTOM, MASK_MAIN, x, y, angle) == true)
                {
                   if(state == CS_HURT)
                   {
                      x_speed = 0;
                      state   = CS_DEFAULT;
                   }
                }
          }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Air drag.

 // Exit if not initialized or death.
    if(is_initialized == true &amp;&amp; state != CS_DEATH)
    {   
        // Air Drag:
           if(ground == false &amp;&amp; state != CS_HURT)
           {
              if(y_speed &lt; 0 &amp;&amp; y_speed &gt;= -4)
              {
                 x_speed -= ((x_speed / 0.125) / 256);
              }
           }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Character States.
 // Executes and/or sets each state of the character.
 
    if(is_initialized &amp;&amp; state != CS_DEATH)
    {
       
 // Sonics insta-shield:    
    if(character_id == CHAR_SONIC)
    {   
       if(global.setting_gameplay_instashield == true)
       {
          sonic_state_insta_shield();
       }
    }
    
 // Sonics peelout:    
    if(character_id == CHAR_SONIC)
    {   
       if(global.setting_gameplay_peelout == true)
       {
          sonic_state_peelout();
       }
    }
    
 // Sonics drop dash:    
    if(character_id == CHAR_SONIC)
    {   
       if(global.setting_gameplay_dropdash == true) 
       {
          sonic_state_dropdash();
       }
    }
    
 // Tails flying.
    if(character_id == CHAR_TAILS)
    {
       miles_state_fly();
    }
    
 // Knuckles glide, climb and slide.
    if(character_id == CHAR_KNUX)
    {
       knuckles_state_glide();
       knuckles_state_climb();
       knuckles_state_slide();
    }
    
 // Shield abilities:
    if(character_id == CHAR_SONIC)
    {
       character_state_shield();
    }
    
 // Jumping state.
 /* Note:
    States that can / should be triggered after a jump, such as a shield ability HAVE to be above
    this script. Otherwise all those scripts will execute while jumping.
 */
    character_state_jump();
    
 // Looking up:
    character_state_look();
    
 // Crouch:
    character_state_crouch();
    
 // Rolling:
    character_state_roll();
    
 // Spindash:
    if(global.setting_gameplay_spindash == true) 
    {
       character_state_spindash();
    }
    
 // Skidding:
    character_state_skid();
    
 // Pushing:
    character_state_push();
    
 // Balance:
    character_state_balance();
    
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input disabling.

 // Exit if not initialized, death or hurt.
    if(is_initialized == true &amp;&amp; state != CS_DEATH &amp;&amp; state != CS_HURT)
    {    
       // Enable input after jumping:
          if(input_lock_s &amp;&amp; !jump_lock &amp;&amp; state == CS_JUMP)
          {
             input_lock_s = 0;
             input_lock_l = 0;
             input_lock_r = 0;          
             lock_timer      = 0;
             input_alarm_dir = 0;
          }
    
       // Disable direction lock when the angle is equal to 0.
          if(input_alarm_dir != 0 &amp;&amp; angle == 0)
          {
             input_alarm_dir = 0;
          }
    
       // Disable spring lock:
          if(lock_timer &lt; 1 &amp;&amp; input_lock_s == true)
          {
             input_lock_s = 0;
             input_lock_l = 0;
             input_lock_r = 0;
          }
    
       // Enable locks:
          if(input_lock_s &amp;&amp; x_speed &gt; 0)
          {
             input_lock_l = 1;
             input_right  = 1;
          }
          else if(input_lock_s &amp;&amp; x_speed &lt; 0)
          {
                  input_lock_r = 1;
                  input_left   = 1;
          }
    
       // Decrease timers.
          if(lock_timer)
          {
             lock_timer -= 1;
          }
          if(lock_timer &lt; 0)
          { 
             lock_timer = 0;
          }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Invincibility/Speedup Timers.

 // Exit if not initialized or death.
    if(is_initialized == true &amp;&amp; state != CS_DEATH)
    {
    
       // Decrease invincibility timer.
          if(invincibility_timer &gt; -1)
          { 
             invincibility_timer -= 1;
             if(invincibility_timer &lt;= 0)
             {
                invincibility       =  0;
                invincibility_timer = -1;
                if(animation_alpha &lt; 1)
                {
                   animation_alpha = 1;
                }
             }
          } 
    
       // Start timer once we land after being hit.
          if(invincibility == 1 &amp;&amp; invincibility_timer == -1)
          {
             if(ground)
             { 
                invincibility_timer = 120;
             }
             if(state != CS_HURT)
             {
                invincibility_timer = 120;
             }
          }
          
       // Speedshoe timer.
          if(speedshoe_timer &gt; 0)
          {
             speedshoe_timer -= 1;
          }
          else
          {
             if(speedshoe_state == 1)
             {
                speedshoe_state = 0;      
                if(afterimage_draw == true)
                {
                   afterimage_draw = false;
                }          
                if(audio_is_playing(_ev_sneakers))
                {
                    audio_stop(_ev_sneakers);
                }                  
             }
          }
                    
       // invincibility sparkles.
            if(invincibility &gt; 1)
            {
               repeat(1)
               {
                  if(instance_number(obj_invincibility_spark) &lt; 3)
                  {
                     instance_create(x, y, obj_invincibility_spark);
                  }
               }
            }
            
       // Stop jingles.
          if(audio_is_playing(_ev_invincibility) &amp;&amp; invincibility == 0)
          { 
             audio_stop(_ev_invincibility);
          }
    
       // Don't show shields.
          if(shield_index != 0 &amp;&amp; invincibility &gt; 1)
          { 
             if(shield_object != noone)
             {
                shield_object.visible = false;
             }
          }
          else
          {
             if(shield_object != noone)
             {
                shield_object.visible = true;
             }     
          }            
            
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Underwater / Drowning.

    if(is_initialized == true &amp;&amp; state != CS_DEATH)
    {
       // Check if the player is currently underwater, we do that by checking the physic state.
          if(physic_state == 1)
          {
             // If the character is wearing a bubble shield, don't run this script.
                if(shield_index != SHIELD_BUBBLE)
                {
                   // Decrease a timer which, once -130 (normally 0 but manias drown theme is longer), kills the character.
                      if(drown_timer &gt; 0)
                      {
                         drown_timer -= 1;
                      }
                      
                   // Start playing the drowning jingle and create the count down.
                      if(drown_timer == 650)
                      {
                         // Audio:
                           if(global.ev_volume != 0.0)
                           {
                              if(audio_is_playing(_ev_drown) == false)
                              {
                                 audio_play(_ev_drown, global.ev_volume);
                              }
                           }
                                                    
                         // Counter:
                            if(instance_exists(obj_drown_counter) == false)
                            {
                               drown_counter = instance_create(x, y-32, obj_drown_counter);
                               drown_counter . parent = id;
                            }                         
                      }
                      
                   // Kill the character.
                      if(drown_timer == 0)
                      {
                        drown_timer = 1800;
                        state       = CS_DEATH;
                        has_drowned = true;                 
                      }
                      
                   // Alarm/Beeping sounds:
                      if(drown_timer mod 400 == 0 &amp;&amp; drown_timer &gt; 650)
                      {
                         // Audio thing.
                            audio_play(_general_drown_alert, global.sfx_volume);
                      }
                      
                   // Bubble state:
                      if(state != CS_BREATHE)
                      {
                         bubble_timer = 0;
                      }
                      else
                      {
                         if(!ground)
                         {
                            if(bubble_timer &lt; 1)
                            {
                               x_speed         = 0;
                               y_speed         = 0;
                               animation_index = "BREATHE";
                            }       
                            if(input_left || input_right)
                            {
                               x_speed += animation_direction*.025;
                            }        
                            if(bubble_timer &lt; 20)
                            {
                               bubble_timer += 1;
                            }
                            else
                            {
                                bubble_timer    = 0;
                                state           = CS_DEFAULT;
                            }
                            drown_timer = 1800;
                            if(instance_exists(drown_counter))
                            {
                                with(drown_counter)
                                {
                                     instance_destroy();
                                }
                                drown_counter = noone;
                            }                  
                            // Stop drowning sound:       
                               if(audio_is_playing(_ev_drown))
                               {
                                  audio_stop(_ev_drown);
                               }                                                                    
                         }
                         else
                         {
                            state       = CS_DEFAULT;
                            drown_timer = 1800;
                            if(instance_exists(drown_counter))
                            {
                                with(drown_counter)
                                {
                                    instance_destroy();
                                }
                                drown_counter = noone;
                            }
                  
                            // Stop drowning sound:       
                                if(audio_is_playing(_ev_drown))
                                {
                                   audio_stop(_ev_drown);
                                }                          
                         }
                      }
                      
                   // Air bubbles:
                      if(drown_timer mod 80 == 0 &amp;&amp; drown_timer &gt; 650)
                      {
                         // Bubble:
                            with(instance_create(x+irandom_range(-7, 8), y-6, obj_water_bubble_small))
                            {
                                 max_frame = choose(0, 3, 8);
                            }
                      }    
                }
                else // Reset timers and destroy the drown counter, if it exists.
                { 
                     drown_timer = 1800;
                     if(instance_exists(drown_counter))
                     {
                        with(drown_counter)
                        {
                             instance_destroy();
                        }
                        drown_counter = noone;
                     }
                  
                  // Stop drowning sound:       
                     if(audio_is_playing(_ev_drown))
                     {
                        audio_stop(_ev_drown);
                     }     
                }          
          }
          else // Above water, reset flags.
          {
                  drown_timer = 1800;
                  if(instance_exists(drown_counter))
                  {
                     with(drown_counter)
                     {
                          instance_destroy();
                     }
                     drown_counter = noone;
                  }
                  
               // Stop drowning sound:       
                  if(audio_is_playing(_ev_drown))
                  {
                     audio_stop(_ev_drown);
                  }                             
          }
    } 
    
 // Drowning bubbles.
    if(state == CS_DEATH &amp;&amp; has_drowned == true)
    {
       if(breath_timer != 0)
       {  
          breath_timer -= 1;
          if(random(4) &gt;= 2)
          {
             bubble = instance_create(x+irandom_range(-7, 8), y-6, obj_water_bubble_small);
             bubble . max_frame = choose(0, 1, 3, 8);
             bubble . depth     = -999995;             
          }
       }
    }    

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Speed Caps.
 // Add your own speed caps here.
 
 // Air cap:
    if(y_speed &gt; 16)
    {
       y_speed = 16;
    }
                         
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Drawing.
 // This script will handle the drawing of the character.
 
 // Flickering:
    if(invincibility == 1 &amp;&amp; invincibility_timer &gt; 0)
    {
       if((global.game_time div 60) mod 3)
       {
          if(miles_tail_sprite != noone)
          {
             draw_sprite_ext(miles_tail_sprite, floor(miles_tail_frame), floor(x+miles_tail_x), floor(y+miles_tail_y), miles_tail_direction, 1, miles_tail_angle, animation_blend, animation_alpha); 
          }         
          draw_sprite_ext(animation_sprite_id, floor(animation_frame), floor(draw_x), floor(draw_y), animation_direction, 1, animation_angle, animation_blend, animation_alpha);
       }
    }
    else
    {
       // Normal Draw: 
          if(miles_tail_sprite != noone)
          {
             draw_sprite_ext(miles_tail_sprite, floor(miles_tail_frame), floor(x+miles_tail_x), floor(y+miles_tail_y), miles_tail_direction, 1, miles_tail_angle, animation_blend, animation_alpha); 
          }        
          draw_sprite_ext(animation_sprite_id, floor(animation_frame), floor(draw_x), floor(draw_y), animation_direction, 1, animation_angle, animation_blend, animation_alpha);
    }

 // Spindash dust:
    if(state == CS_SPINDASH)
    { 
       draw_sprite_ext(spr_spindash_dust, current_time div 25, floor(draw_x-animation_direction*1), floor(draw_y), animation_direction, 1, 0, c_white, animation_alpha);
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
